/**
 * GridBrowser instance, manages the maps preview grid
 */
var g_MapBrowser;

/**
 * Handles map list search behaviour
 */
var g_MapsSearchBox;

/**
 * @var g_Maps {Object}
 * @var g_Maps.ofTypeAndFilter {Object}
 * Object with filters by map type from which each
 * map type has an object with maps by filter.
 * {
 *   "random" : {
 *      "default": [new Map, ...],
 *      "naval": [new Map, ...],
 *      "new": [new Map, ...],
 *      "trigger": [new Map, ...],
 *      "all": [new Map, ...],
 *      ...
 *   },
 *   "skirmisher": {
 *       "default" : [new Map, ...],
 *       ....
 *   },
 *   "scenario": ....,
 * }
 */
var g_Maps = {
	"types": arrayToKeys(g_Settings_for_MapBrowser.MapTypes, "Name"),
	"filters": arrayToKeys(g_Settings_for_MapBrowser.MapFilters, "id"),
	"ofTypeAndFilter": {}, // Lazy loaded
	"ofFilter": {}, // Lazy loaded
	"getFromTypeAndFilter": function (type = currentType(), filter = currentFilter())
	{
		if (!(type in this.types) || !(filter in this.filters))
			return [];

		if (!(type in this.ofTypeAndFilter))
			this.ofTypeAndFilter[type] = {
				"all": listFiles(this.types[type].Path, this.types[type].Extension, false).
					filter(fileName => !fileName.startsWith("_")).
					map(fileName => new Map(fileName, type))
			};

		if (!(filter in this.ofTypeAndFilter[type]))
			this.ofTypeAndFilter[type][filter] = this.ofTypeAndFilter[type].all.
				filter(map => this.filters[filter].filter(map.filter));

		return this.ofTypeAndFilter[type][filter];
	},
	"getFromFilter": function (filter = currentFilter())
	{
		if (!(filter in this.filters))
			return [];

		if (!(filter in this.ofFilter))
		{
			this.ofFilter[filter] = [];
			for (let type in g_Maps.types)
				this.ofFilter[filter].push(...this.getFromTypeAndFilter(type, filter));
		}

		return this.ofFilter[filter];
	}
};

var g_MatchSort = {
	// The lower the score the better the match
	"scoreText": function (input, text)
	{
		if (!input || !text)
			return undefined;

		text = text.toLowerCase();

		let score = 0;
		let offset = -1;
		for (let i = 0; i < input.length; i++)
		{
			let char = input[i];
			let offsetNext = text.indexOf(char, offset + 1);
			// No match
			if (offsetNext == -1)
				return undefined;

			// No score increase if consecutive index
			let bias = offsetNext == offset + 1 ? 0 : 1;
			score += bias * i + offsetNext - offset - 1;
			offset = offsetNext;
		}

		return score;
	},
	/**
	 * Returns a new list filtered and sorted by the similarity with the input text
	 * @param {string} input text to seach for
	 * @param {string[] | object[]} list
	 * @param {string} [key] text to use if the list is made up of objects
	 */
	"search": function (input, list, key = null)
	{
		input = input.toLowerCase();

		let result = [];

		if (key == null)
			for (let text of list)
			{
				let score = this.scoreText(input, text);
				if (score !== undefined)
					result.push([score, text])
			}
		else
			for (let obj of list)
			{
				let score = this.scoreText(input, obj[key]);
				if (score !== undefined)
					result.push([score, obj])
			}

		result.sort((a, b) => a[0] - b[0]);
		return result.map(v => v[1]);
	}
}

/**
 * Stores what is the current selected map if any
 */
var g_MapSelected = {
	"select": function (map, child)
	{
		if (this.lastSelectedChild)
			this.lastSelectedChild.onUnselect();

		this.lastSelectedChild = child;

		this.filter = currentFilter();
		if (this.map == map)
			return;

		this.selected = true;
		this.map = map;

		Engine.GetGUIObjectByName("nameSelected").caption = this.map.name;
		Engine.GetGUIObjectByName("previewSelected").sprite = this.map.preview;
		Engine.GetGUIObjectByName("descriptionSelected").caption = this.map.description;
		Engine.GetGUIObjectByName("selectMapButton").enabled = true;
	},
	"selected": false,
	"lastSelectedChild": undefined,
	"map": {}
};

/**
 *  Stores zoom in/out functions and level of zoom
 */
var g_MapZoom = {
	"originalSize": { "width": 400, "height": 300 },
	"scale": 0.6,
	"multiplier": 1.1,
	"getWidth": function () { return this.originalSize.width * this.scale; },
	"getHeight": function () { return this.originalSize.height * this.scale; },
	"zoom": function (step)
	{
		this.scale *= Math.pow(this.multiplier, step)
		this.scale = Math.max(Math.min(this.scale, 2.0), 0.35);
		g_MapBrowser.setChildDimensions(this.getWidth(), this.getHeight());
	}
};

var g_GUIObjects = {
	"mapsZoomIn":
	{
		"tooltip": translate(setStringTags("\\[" + "MouseWheelUp" + "]", g_HotkeyTags) + ": Make map previews bigger."),
		"onPress": () => g_MapZoom.zoom(1)
	},
	"mapsZoomOut":
	{
		"tooltip": translate(setStringTags("\\[" + "MouseWheelDown" + "]", g_HotkeyTags) + ": Make map previews smaller?"),
		"onPress": () => g_MapZoom.zoom(-1)
	},
	"prevButton":
	{
		"tooltip": colorizeHotkey(translate("%(hotkey)s: Goes to previous page."), "tab.prev"),
		"onPress": () => g_MapBrowser.previousPage()
	},
	"nextButton":
	{
		"tooltip": colorizeHotkey(translate("%(hotkey)s: Goes to next page."), "tab.next"),
		"onPress": () => g_MapBrowser.nextPage()
	},
	"selectMapButton":
	{
		"tooltip": translate("Select map."),
		"onPress": () => close(true)
	},
	"closeButton":
	{
		"tooltip": colorizeHotkey(translate("%(hotkey)s: Close map browser."), "cancel"),
		"onPress": () => close(false)
	},
	"dialog":
	{
		"onWindowResized": () => g_MapBrowser.generateGrid().goToPageOfSelected(),
		"onMouseWheelUp": () => g_MapBrowser.nextPage(),
		"onMouseWheelDown": () => g_MapBrowser.previousPage()
	},
	"MapBrowserContainer":
	{
		"onMouseWheelUp": () => g_MapBrowser.nextPage(),
		"onMouseWheelDown": () => g_MapBrowser.previousPage()
	}
};

var g_Dropdowns = {
	"mapTypeDropdown":
	{
		"list_data": () => Object.keys(g_Maps.types),
		"list": () => Object.keys(g_Maps.types).map(type => g_Maps.types[type].Title),
		"selected": (type, filter) => Object.keys(g_Maps.types).indexOf(type),
		"onSelectionChange": () => () => g_MapBrowser.setList(g_Maps.getFromTypeAndFilter())
	},
	"mapFilterDropdown":
	{
		"list_data": () => Object.keys(g_Maps.filters),
		"list": () => Object.keys(g_Maps.filters).map(filter => g_Maps.filters[filter].name),
		"onSelectionChange": () => () => g_MapBrowser.setList(g_Maps.getFromTypeAndFilter()),
		"selected": (type, filter) => Object.keys(g_Maps.filters).indexOf(filter)
	}
}

var g_GlobalHotkeys = {
	"tab.prev": () => g_MapBrowser.previousPage(),
	"tab.next": () => g_MapBrowser.nextPage()
};

/**
 * @param {Object} data - context data sent by the gamesetup
 */
function init(data)
{
	g_MapBrowser = new GridBrowser(
		"MapBrowserContainer",
		"MapBrowserContainerCurrentPage",
		[],
		g_MapZoom.getWidth(),
		g_MapZoom.getHeight(),
		childFunction
	).generateGrid();

	for (let name in g_GUIObjects)
		for (let parameter in g_GUIObjects[name])
			Engine.GetGUIObjectByName(name)[parameter] = g_GUIObjects[name][parameter];

	let type = data && data.map && data.map.type in g_Maps.types ? data.map.type : "random";
	let filter = data && data.map && data.map.filter in g_Maps.filters ? data.map.filter : "default";
	for (let name in g_Dropdowns)
		for (let parameter in g_Dropdowns[name])
			Engine.GetGUIObjectByName(name)[parameter] = g_Dropdowns[name][parameter](type, filter);

	for (let hotkey in g_GlobalHotkeys)
		Engine.SetGlobalHotkey(hotkey, g_GlobalHotkeys[hotkey]);

	// Simulate a click on intial selected map (if any)
	if (data && data.map && data.map.name != "random")
	{
		let index = g_MapBrowser.list.findIndex(map => map.file.path + map.file.name == data.map.name);
		if (index != -1)
			g_MapBrowser.goToPageOfIndex(index).getChildOfIndex(index).onSelect();
	}

	g_MapsSearchBox = new MapsSearchBox("mapsSearchBox");
	Engine.GetGUIObjectByName("mapsSearchBox").focus();
}

/**
 * Handles the behaviour of each map preview in the map browser grid.
 * All parameters are feeded to the each non hidden child that is is shown.
 * This function will be binded with the GridBrowser instance.
 * @param {GUIObject} child
 * @param {Number} childIndex
 * @param {Any} data
 * @param {Number} dataIndex
 */
function childFunction(child, childIndex, map, mapIndex)
{
	if (child.onUnselect)
		child.onUnselect();

	let mapPreview = child.children[0].children[0];
	let childSelected = false;

	child.onMouseLeftPress = () =>
	{
		g_MapSelected.select(map, child);
		this.setSelectedIndex(mapIndex);
		if (childSelected)
			return;

		child.sprite = "color: 120 0 0 255";
		childSelected = true;
	};
	child.onUnselect = () =>
	{
		if (!childSelected)
			return;

		child.sprite = "";
		childSelected = false;
	};
	child.onSelect = child.onMouseLeftPress.bind(child);

	child.onMouseWheelUp = () => this.nextPage();
	child.onMouseWheelDown = () => this.previousPage();
	child.onMouseLeftDoubleClick = () => close(true);
	child.onOver = () => close(true);

	if (map == g_MapSelected.map)
		child.onSelect();

	mapPreview.caption = map.name;
	mapPreview.sprite = map.preview;
	child.tooltip = map.description;
};

/**
 * Uses one element of the array as key to make a dictionary
 * @param {Array} dict
 * @param {String} element
 * @return {Object}
 */
function arrayToKeys(objectsArray, element)
{
	let dict = {};
	for (let object of objectsArray)
	{
		dict[object[element]] = {};
		for (let key in object)
			if (key != element)
				dict[object[element]][key] = object[key];
	}
	return dict;
}

function currentType()
{
	let mapTypeDropdown = Engine.GetGUIObjectByName("mapTypeDropdown");
	if (mapTypeDropdown.selected != -1)
		return mapTypeDropdown.list_data[mapTypeDropdown.selected];
}

function currentFilter()
{
	let mapFilterDropdown = Engine.GetGUIObjectByName("mapFilterDropdown");
	if (mapFilterDropdown.selected != -1)
		return mapFilterDropdown.list_data[mapFilterDropdown.selected];
}

/**
 * Each map has all his data in this object
 */
class Map
{
	// fileName and type are assumed to be valid
	constructor(fileName, type)
	{
		this.type = type;
		this.file = {
			"path": g_Maps.types[type].Path,
			"name": fileName,
			"extension": g_Maps.types[type].Extension
		};
	}

	static previewPrefix()
	{
		return `cropped:${400 / 512},${300 / 512}:session/icons/mappreview/`;
	}

	parseData(key, alternative)
	{
		return this.data && this.data.settings && key in this.data.settings ?
			this.data.settings[key] : alternative;
	}

	get data()
	{
		return "_data" in this ? this._data :
			this._data = this.type == "random" ?
				Engine.ReadJSONFile(this.file.path + this.file.name + this.file.extension) :
				Engine.LoadMapSettings(this.file.path + this.file.name);
	}

	get name()
	{
		return "_name" in this ? this._name :
			this._name = translate(this.parseData("Name", "No map name."));
	}

	get description()
	{
		return "_description" in this ? this._description :
			this._description = translate(this.parseData("Description", "No map description."));
	}

	get preview()
	{
		return "_preview" in this ? this._preview :
			this._preview = Map.previewPrefix() + this.parseData("Preview", "nopreview.png");
	}

	get filter()
	{
		if ("_filter" in this)
			return this._filter;

		this._filter = this.parseData("Keywords", ["all"]);
		if (!Array.isArray(this._filter))
			this._filter = [this._filter];
		return this._filter;
	}
}

class MapsSearchBox
{
	constructor(GUIObjectName)
	{
		this.input = Engine.GetGUIObjectByName(GUIObjectName);
		this.input.onTab = g_MapBrowser.nextPage.bind(g_MapBrowser);
		this.input.onMouseLeftPress = this.updateSearch.bind(this);
		this.input.onPress = this.selectFirstResult.bind(this);
		this.input.onTextedit = this.updateSearch.bind(this);

		this.placeholder = this.input.children[0];
	}

	selectFirstResult()
	{
		if (!g_MapBrowser.list.length)
			return;

		g_MapSelected.select(g_MapBrowser.list[0]);
		close(true);
	}

	updateSearch()
	{
		let caption = this.input.caption.trim().toLowerCase();
		if (this.placeholder)
			this.placeholder.hidden = !!caption;

		let list = g_Maps.getFromTypeAndFilter();
		if (caption)
		{
			// Search all maps with current type and filter
			list = g_MatchSort.search(caption, list, "name");

			// Search all maps with current filter
			if (!list.length)
				list = g_MatchSort.search(caption, g_Maps.getFromFilter(), "name");
		}

		g_MapBrowser.setList(list).goToPage(0);
	}
}


function close(sendSelected)
{
	if (sendSelected && g_MapSelected.selected)
		Engine.PopGuiPage({
			"map": {
				"path": g_MapSelected.map.file.path,
				"name": g_MapSelected.map.file.name,
				"type": g_MapSelected.map.type,
				"filter": g_MapSelected.filter
			}
		});
	else
		Engine.PopGuiPage({})
}
